# coding=utf8
###
# Copyright (c) 2010, Terje Hoås
# All rights reserved.
#
#
###
import codecs
import urllib2
import os.path
import supybot.utils as utils
from supybot.commands import *
import supybot.conf as conf
import supybot.plugins as plugins
import supybot.ircmsgs as ircmsgs
import supybot.ircutils as ircutils
import supybot.callbacks as callbacks


class Temperature(callbacks.Plugin):
    """Help is on the TODO list. Try again later. Actually, I lied; I don't have a TODO list"""
    #"""Add the help for "@plugin help Temperature" here
    #This should describe *how* to use this plugin."""
    threaded = True

    def __init__(self, irc):
        self.__parent = super(Temperature, self)
        self.__parent.__init__(irc)

    def _sunRise(self, url):
        try:
            url.encode('iso-8859-1')
            req = urllib2.Request(url)
            f = urllib2.urlopen(req)
            html = f.read()
        except:
            print 'Failed to read from ' + url
            return -1
        name = self._findName(html, False)
        try:
            html = html[html.find('sunrise'):]
            html = html[html.find('>')+1:]
            html = html[:html.find('</ul>')]
            html = html.strip()
            html = html.split("</li>")
            for i in range(len(html)):
                html[i] = html[i].strip()
                if(html[i] == ""):
                    html.pop(i)
            ret = ""
            if(len(html) == 1):
                html[0] = html[0][html[0].find(">")+1:]
                ret = html[0]
            elif(len(html) == 2):
                for i in range(len(html)):
                    html[i] = html[i][html[i].find(">")+1:]
                ret = html[0] + ". " + html[1] + "."
            if (name == -1):
                return ret
            else:
                return ret + " (" + name + ")"
        except:
            print "Failed finding sunrise / sunset"
            return -1

    def _moonRise(self, url):
        try:
            url.encode('iso-8859-1')
            req = urllib2.Request(url)
            f = urllib2.urlopen(req)
            html = f.read()
        except:
            print 'Failed to read from ' + url
            return -1
            #<ul class="sunrise">
            #<li>Det er midnattssol, sola går ikke ned.</li>
            #</ul>
            #<ul class="moonrise">
            #<li title="10.05.2010 står månen opp 1:44">Månen opp 01:44</li>
            #<li title="10.05.2010 går månen ned 19:53">Månen ned 19:53</li>
            # </ul>
        name = self._findName(html, False)
        try:
            html = html[html.find('moonrise'):]
            html = html[html.find('>')+1:]
            html = html[:html.find('</ul>')]
            html = html.strip()
            html = html.split("</li>")
            for i in range(len(html)):
                html[i] = html[i].strip()
                if(html[i] == ""):
                    html.pop(i)
            ret = ""
            if(len(html) == 1):
                html[0] = html[0][html[0].find(">")+1:]
                ret = html[0]
            elif(len(html) == 2):
                for i in range(len(html)):
                    html[i] = html[i][html[i].find(">")+1:]
                ret = html[0] + ". " + html[1] + "."
            if (name == -1):
                return ret
            else:
                return ret + " (" + name + ")"
        except:
            print "Failed finding moonrise / moonset"
            return -1
    def _findName(self, html, fetchself):
        # html is a string. The string is either an url or html-code
        # incase of html-code we better hope fetchself is True
        if(fetchself):
            try:
                html.encode('iso-8859-1')
                req = urllib2.Request(html)
                f = urllib2.urlopen(req)
                html = f.read()
            except:
                print 'Failed to read from ' + html
                return -1
        # Find the following:
        # <div class="title-crumbs">
        # last <li>s before </ul>
        try:
            html = html[html.find('<div class="title-crumbs">'):]
            html = html[:html.find("</ul>")]
            html = html.split("</li>")
            html = html[len(html)-2].strip()
            html = html[html.find(">")+1:]
            return html
        except:
            return -1

    def _extractFromYr(self, url):
        try:
            url.encode('utf-8')
            req = urllib2.Request(url)
            f = urllib2.urlopen(req)
            html = f.read()
        except:
            print 'Failed to read from ' + url
            return -1, -1, -1,-1, -1, -1,
        # print 'HTML: ' + html
        try:
            splitstring = '<div class="single-observations">'
            firstenc = html.find(splitstring)
            secenc = html.find(splitstring, firstenc+1)
            html = html[firstenc:secenc]
            # html is at this point just the html code for the closest measuring station
        except:
            print 'Temp failed at first split.'
            return -1, -1, -1,-1, -1, -1,
        try: 
            # finds the name in the <h3> tag.
            name = html[html.find('<h3>')+4:html.find('</h3>')]
             
            # Remove everything that's not in the <table> tag
            
            first = html.find('<table>') + 7
            second = html.find('</table>')
    
            html = html[first:second]
        except:
            print 'Temp failed at extracting table.'
            return -1, -1, -1,-1, -1, -1,
        try: 
            # We have at this point 3x <tr>
            # We only want info from the 2nd row.
            
            first = html.find('<tr>') + 4
            second = html.find('<tr>', first) + 4 
            html = html[second:]
            
            first = html.find('</tr>')
            html = html[:first].strip()
            
            html = html.split('</td>')
                    
            html.reverse()
    
        except:
            print 'Temp failed at extracting rows.'
            return -1, -1, -1,-1, -1, -1,
            
            """
            In case of len(html) == 3:
                index 0: empty
                index 1: wind
                index 2: temperature
            
            in case of len(html) == 4:
                index 0: empty
                index 1: wind
                index 2: temperature
                index 3: weathertype
            """
            
        try: 
            # Guess this one is useless
            # after some testing, it might actually be useful
            for i in range(len(html)):
                html[i] = html[i].strip()
            
            # nothing
            # html[0]
            if len(html) == 3 or len(html) == 4:
                # wind
                if html[1] == '<td>':
                    winddesc = -1
                else:
                    winddesc = html[1][html[1].find('>')+1:]
                # temp
                
                tempdesc = html[2][html[2].find('>')+1:]
                
        except:
            print 'Temp failed at temp/winddesc.'
            return -1, -1, -1,-1, -1, -1,
            
        try: 
            # weathertype
            if len(html) == 4:
                start = html[3].find('alt="')+5 #+5 because alt= is 4 chars, and we want to start after that.
                stop = html[3].find('"', start)
                weathertype = html[3][start:stop]
            else:
                weathertype = -1
        except:
            print lols
            
        try:
            # we know the last letter is the degree sign, which I can't write here atm.
            l = tempdesc.__len__()
            tempdigit = float(tempdesc[0:l-2].replace(',', '.'))
            if winddesc != -1:
                start = winddesc.find(", ") + 2
                stop = winddesc.find("m/s")-2
                winddigit = float(winddesc[start:stop].replace(',', '.').strip())
            else:
                winddigit = -1
                
            
            """
            print 'Name: ' + str(name)
            print 'Weather type: ' + str(weathertype)
            print 'Temperature description: ' + str(tempdesc)
            print 'Wind description: ' + str(winddesc)
            print 'Temperature as digit: ' + str(tempdigit)
            print 'Wind speed as digit: ' + str(winddigit)
            print '{0}. {1}. {2}'.format(tempdesc, weathertype, winddesc)
            """
            
            return name, weathertype, tempdesc, winddesc, tempdigit, winddigit
        except:
            print "Try failed. Returning only -1."
            # Try to find first forecast i XML
            return -1, -1, -1,-1, -1, -1,
    
    def _getURL(self, irc, msg, args, channel, loc, url, lock):
        dataDir = conf.supybot.directories.data
        
        channel = channel.lower()
        chandir = dataDir.dirize(channel)
        if not os.path.exists(chandir):
            os.makedirs(chandir)
            
        dataDir = dataDir.dirize(channel + "/Temperature.db")
        if not os.path.isfile(dataDir):
            open(dataDir, 'w')
        
        # If location is not set, it defaults to .. uhm, default
        if not loc:
            loc = 'default'
        newurl = False
        if url:
            # In case we get a random retarted url
            if not url.startswith('http://www.yr.no/'):
                irc.reply('No you.')
                return -1
            newurl = True
            # url = url.decode('iso-8859-1')
        
        
        # logfile = codecs.open(dataDir,'r','utf8')
        logfile = open(dataDir, 'r')
        # Reads the current log
        log = logfile.read()
        lines = log.splitlines()
        
        #if loc and not url:
        #if loc and url:
        
        # For every line (in the Temperature.db file) we check if the first word 
        # is the location we are trying to set. If it is we need to replace it.
        for i in range(len(lines)):
            s = lines[i].split('\t')
            
            # Incase input location is found, could use 'if s[0] == loc.lower():' to be more exact.
            if s[0].startswith(loc.lower()):
                # this is the default hit
                # If there is no input url we read the url from the file (s[1])
                if not url:
                    url = s[1]
                    break
                # incase of url present
                else:
                    # if both location and url are there already, we are all done.
                    if s[1] == url:
                        # Url and location already exists. We are done.
                        irc.reply('Location and URL are already added.')
                        return -1
                    # == 'lock' is probably useless if wrap() is used right.
                    elif len(s) == 3 and s[2] == 'lock':
                        irc.reply('The URL for this location has been locked.')
                        return -1
                    # if the url is different
                    lines[i] = loc.lower() + '\t' + url
                    # == 'lock' is probably useless if wrap() is used right.
                    if lock and lock == 'lock':
                        lines[i] = lines[i] + "\tlock"
                
                    # Updates the url (rewrites the entire file)
                    open(dataDir, 'w')
                    # logfile = codecs.open(dataDir,'a','utf8')
                    logfile = open(dataDir, 'a')
                    for i in range(len(lines)):
                        logfile.write(lines[i] + '\n')
                    irc.replySuccess()
                    return -1
            
        # If new location, append
        if newurl:
            # logfile = codecs.open(dataDir,'a','utf8')
            logfile = open(dataDir, 'a')
            if lock and lock == 'lock':
                logfile.write(loc.lower() + '\t' + url + '\tlock\n')
            else:
                logfile.write(loc.lower() + '\t' + url + '\n')
            irc.replySuccess()
            return -1
        # Happens when URL was not found in db.
        # Can be for both default and non-default location
        if not url:
            if loc == 'default':
                irc.reply("No default location added for this channel. See help temp")
            else:
                irc.reply("No such location added for this channel. See help temp")
            return -1
        else:
            return url
    
    def _pollen(self, locations, loc):
        # locations is the dictionary, loc is the integer
        url = "http://www.yr.no/pollen/"
        try:
            url.encode('iso-8859-1')
            req = urllib2.Request(url)
            f = urllib2.urlopen(req)
            html = f.read()
        except:
            print 'Failed to read from ' + url
            return -1
        first = "<h2>" + locations[loc] + "</h2>"
        # Dropping everything after our first find
        html = html[html.find(first):]
        first = "<tfoot>"
        # Do the same again (kinda redundant step)
        html = html[html.find(first):]
        
        first = '<td colspan="2">'
        html = html[html.find(first):]
        first = ">"
        # Now we drop the > aswell.
        html = html[html.find(first)+1:]
        
        first = "<"
        
        today = html[:html.find(first)]
        
        # Try to find the string for the next day
        # Actually exactly the same as we did last time.
        first = "<tfoot>"
        html = html[html.find(first):]
        first = '<td colspan="2">'
        html = html[html.find(first):]
        first = ">"
        html = html[html.find(first)+1:]
        first = "<"
        tomorrow = html[:html.find(first)]
        today = today.strip()
        tomorrow = tomorrow.strip()
        return today + " " + tomorrow + " (" + locations[loc] + ")"
        """
        html = html[html.find('sunrise'):]
        html = html[html.find('>')+1:]
        html = html[:html.find('</ul>')]
        html = html.strip()
        html = html.split("</li>")
        """
    def pollen(self, irc, msg, args, loc):
        """[<location>]
        
        Norwegian only. See "pollen list" for list of locations. 
        """
        
        if (loc == "list"):
            irc.reply("1 Østlandet med Oslo, 2 Sørlandet, 3 Rogaland, 4 Hordaland, \
5 Sogn og Fjordane, 6 Møre og Romsdal, 7 Sentrale fjellstrøk i Sør-Norge, 8 Indre Østlandet, \
9 Trøndelag, 10 Nordland, 11 Troms, 12 Finnmark")
            # Might aswell exit at this point.
            return
        
        # Dictionary with locations
        locations = {1: "Østlandet med Oslo", 
                2: "Sørlandet", 
                3: "Rogaland", 
                4: "Hordaland",
                5: "Sogn og Fjordane", 
                6: "Møre og Romsdal",
                7: "Sentrale fjellstrøk i Sør-Norge",
                8: "Indre Østlandet", 
                9: "Trøndelag", 
                10: "Nordland", 
                11: "Troms", 
                12: "Finnmark"}
        # Defaults to "Trøndelag"
        if not loc:
            loc = 9
        try:
            loc = int(loc)
            # If the parsing fails we jump to the except.
        # if location is not an integer
        except:
            for l in locations:
                # If we have location that containt the string
                # Using lower() to ignore case.
                if(locations[l].lower().find(loc.lower()) != -1):
                    loc = l
                    break
            # If we have gone through the loop and loc still isn't an integer  the location is not found
        
        # If number is outside the accepted range.
        if(loc < 1 or loc > 12):
            irc.reply('Sorry, ' + str(loc) + ' is not a valid location. \
Check "pollen list" for list of locations.')
            return
        # At this point loc is an integer from 1 to 12
        retstr = self._pollen(locations, loc)
        if (retstr == -1):
            irc.reply('Sorry, failed to retrieve pollentriks.')
        else:
            irc.reply(retstr)
    pollen = wrap(pollen, [additional('text')])
    
    def locations(self, irc, msg, args, channel):
        """[<channel>]
        
        Display locations added for this channel and alias used. 
        You can add locations through the commands 'temp', 'sun' and 'moon'.
        """
        dataDir = conf.supybot.directories.data
        
        channel = channel.lower()
        chandir = dataDir.dirize(channel)
        if not os.path.exists(chandir):
            irc.reply("No locations found for current channel.")
            return
            
        dataDir = dataDir.dirize(channel + "/Temperature.db")
        if not os.path.isfile(dataDir):
            irc.reply("No locations found for current channel.")
            return
        
        # logfile = codecs.open(dataDir,'r','utf8')
        logfile = open(dataDir, 'r')
        # Reads the current log
        log = logfile.read()
        lines = log.splitlines()
        
        loc = {}
        # For every line (in the Temperature.db file) we get the location
        for i in range(len(lines)):
            s = lines[i].split('\t')
            if(s[1] != None):
                name = self._findName(s[1], True)
            if(name and name == -1):
                name = "???"
            loc[s[0]] = name
            
            
        locs_list = loc.items()
        
        locs_list = sorted(locs_list, key=lambda x:x[0])
               
        output = ""
        for i in range(len(locs_list)):
            if(i+1 != len(locs_list)):
                output += locs_list[i][0] + " (" + locs_list[i][1] + "), "
            else:
                output += locs_list[i][0] + " (" + locs_list[i][1] + ")."   
                
        irc.reply(output)
    locations = wrap(locations, ['channeldb'])
    
    
    def sun(self, irc, msg, args, channel, loc, url, lock):
        """[<channel>] [<location>] 
        
        See help for temp for more information. Same parameters apply here.
        """
        url = self._getURL(irc, msg, args, channel, loc, url, lock)
        if (url == -1):
            return
        sunrise = self._sunRise(url)
        if (sunrise == -1):
            irc.reply('Sorry, failed to retrieve sunrise and/or sunset from ' + url)
        else:
            irc.reply(sunrise)
    sun = wrap(sun, ['channeldb', optional('anything'), additional('HttpUrl'), optional('anything')])
    
    def moon(self, irc, msg, args, channel, loc, url, lock):
        """[<channel>] [<location>] 
        
        See help for temp for more information. Same parameters apply here.
        """
        url = self._getURL(irc, msg, args, channel, loc, url, lock)
        if (url == -1):
            return
        moonrise = self._moonRise(url)
        if (moonrise == -1):
            irc.reply('Sorry, failed to retrieve moonrise and/or moonset from ' + url)
        else:
            irc.reply(moonrise)
    moon = wrap(moon, ['channeldb', optional('anything'), additional('HttpUrl'), optional('anything')])
    
    def temp(self, irc, msg, args, channel, loc, url, lock):
        """[<channel>] [<location> [<yr.no URL for location>]]

        Channel is only needed if message is not in channel. 
        Location and yr.no-url for location is needed for storing locations.
        Location gets the temperature from the url it is stored with.
        To use the command without arguments you must first set a url for location "default".
        """
        url = self._getURL(irc, msg, args, channel, loc, url, lock)
        if (url == -1):
            return
        #url = "http://www.yr.no/sted/Norge/S%C3%B8r-Tr%C3%B8ndelag/Trondheim/Voll/"
        #url = "http://www.yr.no/place/Norway/S%C3%B8r-Tr%C3%B8ndelag/Trondheim/Voll/"
        #url = "http://www.yr.no/place/Norway/Nord-Tr%C3%B8ndelag/Stj%C3%B8rdal/Trondheim_lufthavn,_V%C3%A6rnes/"
        name, weathertype, tempdesc, winddesc, tempdigit, winddigit = self._extractFromYr(url)
        print '-------------'
        print 'Name: \t\t' + str(name)
        print 'Weathertype: \t' + str(weathertype)
        print 'Temperature: \t' + str(tempdesc)
        print 'Wind: \t\t' + str(winddesc)
        print '-------------'
        if tempdesc == -1:
            irc.reply('Sorry, failed to retrieve weather from ' + url)
            return
        usechill = True
        if winddesc == -1:
            usechill = False
        
        # Ugly hack to stop non-ascii error without using unicode ;)
        try:
            degree = tempdesc[tempdesc.index(",")+2:tempdesc.__len__()]
        except:
            try:
                degree = tempdesc[tempdesc.index(".")+2:tempdesc.__len__()]
            except:
                # If we ended up here, then the degree sign could not be located, so we skip the windchill calculating.
                usechill = False
                
        if tempdigit < 10 and (winddigit*3.6) > 4.8 and usechill:
            windchill = 13.12 + 0.6215 * tempdigit - 11.37 * ((winddigit * 3.6)**0.16) + 0.3965 * tempdigit * ((winddigit * 3.6)**0.16)
            if weathertype != -1:
                rep = '%s (%.1f%s). %s. %s (%s)' % (tempdesc, windchill, degree, weathertype, winddesc, name)
                # rep = tempdesc + ' (' + str(windchill) + degree + '). ' + weathertype + '. ' + winddesc + ' (' + name + ')'
                #rep = '{0} ({1:.1f}{2}). {3}. {4} ({5})'.format(tempdesc, windchill, degree, weathertype, winddesc, name)
            else:
                rep = '%s (%.1f%s). %s (%s)' % (tempdesc, windchill, degree, winddesc, name)
                # rep = tempdesc + ' (' + str(windchill) + degree + '). ' + winddesc + ' (' + name + ')'
                #rep = '{0} ({1:.1f}{2}). {3} ({4})'.format(tempdesc, windchill, degree, winddesc, name)
        else:
            if weathertype != -1 and winddesc != -1:
                rep = '%s. %s. %s (%s)' % (tempdesc, weathertype, winddesc, name)
                # rep = tempdesc + '. ' + weathertype + '. ' + winddesc + ' (' + name + ')'
                #rep = '{0}. {1}. {2} ({3})'.format(tempdesc, weathertype, winddesc, name)
            elif weathertype == -1 and winddesc != -1:
                rep = '%s. %s (%s)' % (tempdesc, winddesc, name)
                # rep = tempdesc + '. ' + winddesc + ' (' + name + ')'
                #rep = '{0}. {1} ({2})'.format(tempdesc, winddesc, name)
            elif weathertype != -1 and winddesc == -1:
                rep = '%s. %s. (%s)' % (tempdesc, weathertype, name)
                # rep = tempdesc + '. ' + weathertype + '. (' + name + ')'
                #rep = '{0}. {1}. ({2})'.format(tempdesc, weathertype, name)
            elif weathertype == -1 and winddesc == -1:
                rep = '%s (%s)' % (tempdesc, name)
                # rep = tempdesc + ' (' + name + ')'
                #rep = '{0}. ({1})'.format(tempdesc, name)
        irc.reply(rep)
    temp = wrap(temp, ['channeldb', optional('anything'), additional('HttpUrl'), optional('anything')])


Class = Temperature


# vim:set shiftwidth=4 softtabstop=4 expandtab textwidth=79:
